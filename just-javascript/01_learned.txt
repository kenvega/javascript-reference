source: https://justjavascript.com/learn

the javascript universe

  what is your code (difference with values)
    your code is not the values you use
    your code interacts with values
    your code is a list of instructions
      if statements, variable declarations, function calls, loops, throws of errors

  primitive values are like distant stars
    you can only point to them
    but you can't create OR destroy OR change them

  objects and functions are like near asteroids
    they are also not part of your code
    but you can manipulate them
    these are also values
    * functions are also objects but with unique features

  types of values
    values of the same type behave similarly
    up to this time there are 9 types

    all primitive types of values
      undefined - unintentionally missing values
      null - intentionally missing values
      booleans 
      numbers - 100, 3.14 
      bigints - for math on big numbers
      strings
      symbols

    the other types - objects and functions
      objects - to group related data
      functions - to refer to code

    there are no more types, the rest are just objects
      arrays, dates, regexs are objects

    not everything is an object in javascript
      for example: "hi".toUpperCase() makes appear that "hi" is an object
        but javascript really creates a temporary object to do this

    checking a type
      the function typeof is like a telescope
        to see the asteroids and distant stars and see what types they have

  expressions
    expressions are questions that javascript can answer
    the answers will always come from javascript as values
    expressions are not values but rather javascript respond to them with values
    expression is a piece of code that
      expresses a value
      evaluates to a value
      results in a value
    examples
      2 + 2 // 4
      typeof(4) // number
      5 // this is a literal expression
        //   we literally write the expression with the result value

values and variables

  primitive values are inmutable
    we can't change primitive values
    inmutable = unchangeable = read-only

    strings mike behave like arrays when accessing the items/characters
      but you can change in arrays the items value
      while you can't change in strings the character
      because arrays are not primitive values

    javascript will never let you change a property of a primitive value
      doesn't matter if it is a string, number, etc

  variables are wires
    variables are not values
    variables are wires that point to values
    variables don't point to other variables
    variables don't have types, only values do
    you can't pass a variable to a function, you can only pass values
      but still: when passing a mutable value to a function, you will be able to change the value passed

    assigning variables to values
      let pet = 'Narwhal';
        assigning the value "Narwhal" to the variable called pet
        or also works:
        point the pet variable to the "Narwhal" value

    rules of assignments
      the left side of assignment needs to be a variable
      the right side of assignment needs to be an expression
        this ensures the right side will always end up being a value
      so in general a wire on the left, and a expression on the right

    reading the value of a variable
      variables can also work as expressions so you can get the current value
      in argument functions, we don't pass variables to functions
        we pass the current value of the variable to the function

studying from the inside
  this course says they won't focus on studying javascript from the outside. this includes things like:
    how javascript values are represented in machines' memories
    strings are actually a sequence of bytes stored in a chip

  rather we will only study javascript from the inside: learning without thinking how it is implemented
    check wires and expressions
    here a string is a value, not a pointer, not a memory address
    also don't focus on things like: "passing by reference", "allocating on stack", "copying on write"
    that's good enough for the mental model
    * this is like studying the properties of a star without questioning if the star really exists

meeting the primitive values

  undefined
    there is only one value of this type of undefined variable: undefined
      console.log(typeof(undefined)); // "undefined"
    reading a property from this value breaks your code
    occurs naturally when javascript doesn't know what value you wanted
      example: forgetting to give a value to a variable will default to undefined

    it doesn't exactly mean that a variable is not defined yet
      if you try to read a variable before its declaration you will get an error
        console.log(someVariable); // ReferenceError!
        let someVariable;

      undefined it's just a regular primitive value like true, 2 or "hello there"

  null
    there is also only one value of this type: null
      *but unlike undefined the typeof function will throw "object" instead of "null" because of a bug in javascript
        console.log(typeof(null)); // "object" <- this is a bug in js because null is not an object
          more on this here: https://2ality.com/2013/10/typeof-null.html

        null is not an object but a primitive value

    it will also throw errors if you try to access its properties

    normally it's used for intentional missing values
      so we can distinguish possible mistakes from real ones related to missing values

  booleans
    there are only two values for this type
      console.log(typeof(true)); // "boolean"
      console.log(typeof(false)); // "boolean"

    in our mental model, only these two values exist one time each
      regardless of how memory works under the hood in our machines

  numbers
    they don't behave exactly as regular mathematical numbers
      console.log(0.1 + 0.2 === 0.3); // false
      console.log(0.1 + 0.2 === 0.30000000000000004); // true

    it uses floating point math (or math for computers)
      don't worry too much about this unless you work in a finance app
      more info here: https://floating-point-gui.de/formats/fp/

    all variables of type number exist in this range
      Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER
      trying to add 1 or more to this will cause errors in javascript
        console.log(Number.MAX_SAFE_INTEGER);     // 9007199254740991
        console.log(Number.MAX_SAFE_INTEGER + 1); // 9007199254740992
        console.log(Number.MAX_SAFE_INTEGER + 2); // 9007199254740992 (again!)
        console.log(Number.MAX_SAFE_INTEGER + 3); // 9007199254740994
        console.log(Number.MAX_SAFE_INTEGER + 4); // 9007199254740996
        console.log(Number.MAX_SAFE_INTEGER + 5); // 9007199254740996 (again!)

    special numbers exist in javascript too
      NaN, Infinity, -Infinity, -0

      let scale = 0;
      let a = 1 / scale; // Infinity
      let b = 0 / scale; // NaN <- not a number. this is for invalid results
      let c = -a; // -Infinity
      let d = 1 / c; // -0

      NaN is still a number type variable
        console.log(typeof(NaN)); // "number"
          it's just that its value is not a valid one

  bigints
    more precise... i guess
    (???)

  strings
    they have some built in properties
      let cat = 'Cheshire';
      console.log(cat.length); // 8
      console.log(cat[0]); // "C"
      console.log(cat[1]); // "h"

    but this doesn't mean string are objects
      if they were objects you could change the properties of them and you can't
        as primitives are inmutable

    in our mental model, all possible string values already exist in our universe from the beginning
      we can't really test this outside of our mental model so take this as a conventio

  symbols
    ...

  source: https://justjavascript.com/learn/05-meeting-the-primitive-values


    

meeting objects and functions